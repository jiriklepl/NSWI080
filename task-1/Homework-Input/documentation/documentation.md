# Task 1 - Java RMI

## Local measurement

- the `Main` implementation was modified to receive the number of vertices and edges as optional arguments for easier measurements

- files `local_measurement_*` were generated by the `local_measurement` bash function in `scripts.sh`
- then the R script `local_measurements.R` generated the two `local_measurements\d.png` files containing the results for the first step of the assignment

![Dependence of Time on Density](local_measurements1.png)

![Dependence of Time on Distance](local_measurements2.png)

## Remote Searcher

- all files were modified as implied by the assignment
  - in the output of `searcherBenchmark`, there are two more columns showing the times for remote searcher
    - the remote tests are done right after their respective local tests
    - the benchmarking function checks validity of the remote distance results
  - the server implementation was based on the `ExampleServer` implementation
- `Node` extends `Serializable` so it gets serialized and sent over the network at once
  - this is quite efficient and each node is sent only once (the serializer understands references)
  - this solution adds a lot of latency towards the first request and a lot of memory overhead
- there is a new class `ServerCommon` which stores data which are shared between the client and the server (e.g the server's name)
- sharing the same simple `SearcherImpl` didn't really work (the instance, which extends `UnicastRemoteObject`, is owned by another thread and survives the Main thread)
  - `SearcherImpl` was reverted to the original state
  - there is a separate `RemoteSearcherImpl` which wraps a `SearcherImpl`, still implementing `Searcher`, instance and extends `UnicastRemoteObject`
