# Task 1 - Java RMI

There will be many mentions of files that no longer exist, they will be stored in git repositories history

## Local measurement

[Snapshot of the files here](https://github.com/jiriklepl/NSWI080/commit/b87eaad090a835128384178c0d0ef799248605f1)

### Implementation

- the `Main` implementation was modified to receive the number of vertices and edges as optional arguments for easier measurements

### Measurement

- 100 files `local_measurement_*` were generated by the `local_measurement` bash function in `scripts.sh`
- then the R script `local_measurements.R` generated the two `local_measurements\d.png` files containing the results for the first step of the assignment

![Dependence of Time on Density](local_measurements1.png)

![Dependence of Time on Distance](local_measurements2.png)

TODO: comment the plots

## Remote Searcher


[Snapshot of the files here](https://github.com/jiriklepl/NSWI080/commit/819bcb62ee3ef36bcc231beb10f8cb37fee62ba0)

### Implementation

- all files were modified as implied by the assignment
  - in the output of `searcherBenchmark`, there are two more columns showing the times for remote searcher
    - the remote tests are done right after their respective local tests
    - the benchmarking function checks validity of the remote distance results
  - the server implementation was based on the `ExampleServer` implementation
- `Node` extends `Serializable` so it gets serialized and sent over the network at once
  - this is quite efficient and each node is sent only once (the serializer understands references)
  - this solution adds a lot of latency towards the first request and a lot of memory overhead
- there is a new class `ServerCommon` which stores data which are shared between the client and the server (e.g the server's name)
- sharing the same simple `SearcherImpl` didn't really work (the instance, which extends `UnicastRemoteObject`, is owned by another thread and survives the Main thread)
  - `SearcherImpl` was reverted to the original state
  - there is a separate `RemoteSearcherImpl` which wraps a `SearcherImpl`, still implementing `Searcher`, instance and extends `UnicastRemoteObject`

### Measurements

- 100 files `remote_searcher_*` were generated by the `remote_searcher` bash function in `scripts.sh`
- then the R script `remote_searcher.R` generated the three `remote_searcher*.png` files containing the results for the first step of the assignment

#### **Dependence of time on density**

![Dependence of Time on Density](remote_searcher1.png)

We can clearly see the overhead of a remote call with serialization, it averages around multiple thousands of nanoseconds. The plots do not show this, but the first request in every set of measurements is accompanied by sending a serialized graph component (there may be more such subsets in each set) which is associated with an overhead higher by multiple orders of magnitude. The subsequent calls where both nodes are in already received components are much faster.

The shape is very distorted by serialization and it doesn't resemble the original plot at [Local measurement](#Local-measurement).

#### **Dependence of time on distance**

![Dependence of Time on Distance](remote_searcher2_1.png)

![Dependence of Time on Distance](remote_searcher2_2.png)

These two plots only further confirm there is a lot of overhead associated with the remote calls with serialization.

## Remote Nodes

[Snapshot of the files here](https://github.com/jiriklepl/NSWI080/commit/b20238a64e9f0b7f1887b9d92c8c9fc2b9f0ad04)

### Implementation

- the files were modified according to the assignment
  - there is `NodeImpl` for local nodes and `RemoteNodeImpl` for remote nodes and their respective factories
  - the methods in `SearcherClient` were reworked to facilitate further implementations
    - `createNodes` takes a `NodeFactory` and returns a graph
    - `connectAllNodes` takes the graph as a parameter
    - `connectSomeNodes` takes an array of graphs as a parameter and connects all graphs similarly
    - `searchBenchmark` takes the graph and the searcher as parameters and then it either takes a number of tests to be performed or a list of indices of nodes it will perform the algorithms on; then the method returns the list of indices the test used (in both cases)
  - the `SearcherCommon` class proved useful as sharing a name of a new class added to `RMI` can be done by adding a new static final field
- old measurements were removed and the `scripts.sh` file was moved to the root folder

### Measurement

- 100 files `remote_nodes_*` were generated by the `remote_nodes` bash function in `scripts.sh`
- then the R script `remote_nodes.R` generated the two `remote_nodes*.png` files containing the results for the first step of the assignment

#### **Dependence of time on density**

![Dependence of Time on Density](remote_nodes1.png)

This graph shows this solution is unsurprisingly even slower than the previous one as there is a continuous stream of `Node`s from the client to the server (overhead of accessing them via function calls).

We can see the plot for "Remote time" copies the shape of the very first plot at [Local measurement](#Local-measurement) which is due to the implementation sending Nodes as they are requested.

#### **Dependence of time on distance**

![Dependence of Time on Distance](remote_nodes2.png)

This graph, once again, resembles the original graph at [Local measurement](#Local-measurement), but its values further confirm the overhead of remote calls.
